/*
 * Hibernate OGM, Domain model persistence for NoSQL datastores
 *
 * License: GNU Lesser General Public License (LGPL), version 2.1 or later
 * See the lgpl.txt file in the root directory or <http://www.gnu.org/licenses/lgpl-2.1.html>.
 */
package org.hibernate.ogm.backendtck.jpa;

import static org.fest.assertions.Assertions.assertThat;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;
import javax.persistence.spi.PersistenceProvider;
import javax.persistence.spi.PersistenceProviderResolver;
import javax.persistence.spi.PersistenceProviderResolverHolder;

import org.hibernate.HibernateException;
import org.hibernate.jpa.HibernatePersistenceProvider;
import org.hibernate.ogm.OgmSessionFactory;
import org.hibernate.ogm.cfg.OgmProperties;
import org.hibernate.ogm.jpa.HibernateOgmPersistence;
import org.hibernate.ogm.utils.PackagingRule;
import org.hibernate.ogm.utils.TestForIssue;
import org.hibernate.ogm.utils.TestHelper;

import org.junit.After;
import org.junit.Before;
import org.junit.Rule;
import org.junit.Test;
import org.junit.rules.ExpectedException;

/**
 * Tests a JPA configuration without defining a persistence provider on it.
 *
 * The order of resolution of the {@link PersistenceProvider}s is unpredictable a priori,
 * then we have to repeat the same test over all possible dispositions.
 * It has to work in every case.
 *
 * @author Fabio Massimo Ercoli
 */
@TestForIssue(jiraKey = "OGM-1517")
public class JPAConfigWithoutProviderTest {

	@Rule
	public PackagingRule packaging = new PackagingRule( "persistencexml/ogm-noprovider.xml", Poem.class );

	@Rule
	public ExpectedException thrown = ExpectedException.none();

	private EntityManagerFactory factory;

	@Test
	public void testNoProviderConfigWhenORMProviderBeforeOGMProvider() {
		ormProviderBeforeOgm();
		Map<String, Object> settings = new HashMap<>( defaultSettingsWithoutOgmEnabledProperty() );

		factory = Persistence.createEntityManagerFactory( "emtpy-configuration-pu", settings );
		assertThat( factory ).isInstanceOf( OgmSessionFactory.class );
	}

	@Test
	public void testNoProviderConfigWhenOGMProviderBeforeORMProvider() {
		ogmProviderBeforeOrm();
		Map<String, Object> settings = new HashMap<>( defaultSettingsWithoutOgmEnabledProperty() );

		factory = Persistence.createEntityManagerFactory( "emtpy-configuration-pu", settings );
		assertThat( factory ).isInstanceOf( OgmSessionFactory.class );
	}

	@Test
	public void testNoProviderConfigWithDefaultProviderResolver() {
		defaultProviderResolver();
		Map<String, Object> settings = new HashMap<>( defaultSettingsWithoutOgmEnabledProperty() );

		factory = Persistence.createEntityManagerFactory( "emtpy-configuration-pu", settings );
		assertThat( factory ).isInstanceOf( OgmSessionFactory.class );
	}

	@Test
	public void testNoProviderConfigWithORMProviderOnly() {
		ormProviderOnly();
		Map<String, Object> settings = new HashMap<>( defaultSettingsWithoutOgmEnabledProperty() );

		factory = Persistence.createEntityManagerFactory( "emtpy-configuration-pu", settings );
		assertThat( factory ).isInstanceOf( OgmSessionFactory.class );
	}

	@Test
	public void testNoProviderConfigWithORMProviderOnlyUsingEnableProperty() {
		defaultProviderResolver();
		Map<String, Object> settings = new HashMap<>( defaultSettingsOgmEnabledTrue() );

		factory = Persistence.createEntityManagerFactory( "emtpy-configuration-pu", settings );
		assertThat( factory ).isInstanceOf( OgmSessionFactory.class );
	}

	@Test
	public void testNoProviderConfigOGMExplicitlyDisabled() {
		// Trying to start ORM with the OGM default setting will cause an exception.
		// The exception is generated by Hibernate ORM,
		// so here we will check just the class and not the text message.
		thrown.expect( HibernateException.class );

		defaultProviderResolver();
		Map<String, Object> settings = new HashMap<>( defaultSettingsOgmEnabledFalse() );

		factory = Persistence.createEntityManagerFactory( "emtpy-configuration-pu", settings );
	}

	@Before
	public void clearResources() {
		this.factory = null;
	}

	@After
	public void closeResources() {
		if ( factory != null ) {
			factory.close();
		}
	}

	private void ormProviderBeforeOgm() {
		PersistenceProviderResolverHolder.setPersistenceProviderResolver(
			new FixedOrderPersistenceProviderResolver( new HibernatePersistenceProvider(), new HibernateOgmPersistence() )
		);
	}

	private void ogmProviderBeforeOrm() {
		PersistenceProviderResolverHolder.setPersistenceProviderResolver(
			new FixedOrderPersistenceProviderResolver( new HibernateOgmPersistence(), new HibernatePersistenceProvider() )
		);
	}

	private void ormProviderOnly() {
		PersistenceProviderResolverHolder.setPersistenceProviderResolver(
			new FixedOrderPersistenceProviderResolver( new HibernatePersistenceProvider() )
		);
	}

	private void defaultProviderResolver() {
		// setting null means setting the default one
		PersistenceProviderResolverHolder.setPersistenceProviderResolver( null );
	}

	private Map<String, String> defaultSettingsWithoutOgmEnabledProperty() {
		Map<String, String> defaultTestSettings = TestHelper.getDefaultTestSettings();

		// even if hibernate.ogm.enabled isn't set to true
		// hibernate OGM would be implicitly started,
		// considering the absence of some properties,
		// mandatory for ORM use cases
		defaultTestSettings.remove( OgmProperties.ENABLED );
		return defaultTestSettings;
	}

	private Map<String, String> defaultSettingsOgmEnabledTrue() {
		Map<String, String> defaultTestSettings = TestHelper.getDefaultTestSettings();
		defaultTestSettings.put( OgmProperties.ENABLED, "true" );
		return defaultTestSettings;
	}

	private Map<String, String> defaultSettingsOgmEnabledFalse() {
		Map<String, String> defaultTestSettings = TestHelper.getDefaultTestSettings();
		defaultTestSettings.put( OgmProperties.ENABLED, "false" );
		return defaultTestSettings;
	}

	private static class FixedOrderPersistenceProviderResolver implements PersistenceProviderResolver {
		private final PersistenceProvider[] providers;

		public FixedOrderPersistenceProviderResolver(PersistenceProvider ... providers) {
			this.providers = providers;
		}

		@Override
		public List<PersistenceProvider> getPersistenceProviders() {
			return Arrays.asList( providers );
		}

		@Override
		public void clearCachedProviders() {

		}
	}
}
