[[ogm-mongodb]]

=== MongoDB

http://www.mongodb.org[MongoDB] is a document oriented datastore
written in C++ with strong emphasis on ease of use.

==== Configuring MongoDB

This implementation is based upon the MongoDB Java driver.
The currently supported version is {mongodb-version}.

The following properties are available to configure MongoDB support:

.MongoDB datastore configuration properties
hibernate.ogm.datastore.provider::
To use MongoDB as a datastore provider, this property must be set to +mongodb+
hibernate.ogm.option.configurer::
The fully-qualified class name or an instance of a programmatic option configurer (see <<ogm-mongodb-programmatic-configuration>>)
hibernate.ogm.datastore.host::
The hostname of the MongoDB instance. The default value is +127.0.0.1+.
hibernate.ogm.datastore.port::
The port used by the MongoDB instance. The default value is +27017+.
hibernate.ogm.datastore.database::
The database to connect to. This property has no default value.
hibernate.ogm.datastore.username::
The username used when connecting to the MongoDB server.
This property has no default value.
hibernate.ogm.datastore.password::
The password used to connect to the MongoDB server.
This property has no default value.
This property is ignored if the username isn't specified.
hibernate.ogm.mongodb.connection_timeout::
Defines the timeout used by the driver
when the connection to the MongoDB instance is initiated.
This configuration is expressed in milliseconds.
The default value is +5000+.
hibernate.ogm.datastore.document.association_storage::
Defines the way OGM stores association information in MongoDB.
The following two strategies exist (values of the +org.hibernate.ogm.options.generic.document.AssociationStorageType+ enum):
+IN_ENTITY+ (store association information within the entity) and
+ASSOCIATION_DOCUMENT+ (store association information in a dedicated document per association).
+IN_ENTITY+ is the default.
hibernate.ogm.mongodb.association_document_storage::
Defines how to store assocation documents (applies only if the +ASSOCIATION_DOCUMENT+
association storage strategy is used).
Possible strategies are (values of the +org.hibernate.ogm.datastore.mongodb.options.AssociationDocumentType+ enum):
* +GLOBAL_COLLECTION+ (default): stores the association information in a unique MongoDB collection for all associations
* +COLLECTION_PER_ASSOCIATION+ stores the association in a dedicated MongoDB collection per association
hibernate.ogm.mongodb.write_concern::
Defines the write concern setting to be applied when issuing writes against the MongoDB datastore.
Possible settings are (values of the +com.mongodb.WriteConcern+ enum): +ERRORS_IGNORED+, +ACKNOWLEDGED+, +UNACKNOWLEDGED+,
+FSYNCED+, +JOURNALED+, +NONE+, +NORMAL+, +SAFE+, +MAJORITY+, +FSYNC_SAFE+,
+JOURNAL_SAFE+, +REPLICAS_SAFE+.
For more information, please refer to the
http://api.mongodb.org/java/current/com/mongodb/WriteConcern.html[official documentation].
This option is case insensitive and the default value is +ACKNOWLEDGED+.

[NOTE]
====
When bootstrapping a session factory or entity manager factory programmatically,
you should use the constants declared on +MongoDBProperties+ and +OgmProperties+
when specifying the configuration properties listed above.
====

[[ogm-mongodb-annotation-configuration]]
===== Annotation based configuration

Hibernate OGM allows to configure store-specific options via Java annotations.
When working with the MongoDB backend, you can specify how associations should be stored
using the +AssociationStorage+ and +AssociationDocumentStorage+ annotations
(refer to <<ogm-mongodb-storage-prinicples>> to learn more about these options).

The following shows an example:

.Configuring the association storage strategy using annotations
====
[source, JAVA]
----
@Entity
@AssociationStorage(AssociationStorageType.ASSOCIATION_DOCUMENT)
@AssociationDocumentStorage(AssociationDocumentType.COLLECTION_PER_ASSOCIATION)
public class Zoo {

    @OneToMany
    private Set<Animal> animals;

    @OneToMany
    private Set<Person> employees;

    @OneToMany
    @AssociationStorage(AssociationStorageType.IN_ENTITY)
    private Set<Person> visitors;

    //...
}
----
====

The annotations on the entity level express that all associations of the +Zoo+
class should be stored in separate assocation documents, using a dedicated collection per association.
This setting applies to the +animals+ and +employees+ associations.
Only the elements of the +visitors+ association will be stored in the document of the corresponding +Zoo+ entity
as per the configuration of that specific property which takes precedence over the entity-level configuration.

[[ogm-mongodb-programmatic-configuration]]
===== Programmatic configuration

In addition to the annotation mechanism,
Hibernate OGM also provides a programmatic API for applying store-specific configuration options.
This can be useful if you can't modify certain entity types or
don't want to add store-specific configuration annotations to them.
The API allows set options in a type-safe fashion on the global, entity and property levels.

When working with MongoDB, you can currently configure the following options using the API:

* write concern (on the global level)
* association storage strategy (on the global, entity and property level)
* association document storage strategy (on the global, entity and property level)

To set these options via the API, you need to create an +OptionConfigurer+ implementation
as shown in the following example:

.Example of an option configurer
====
[source, JAVA]
----
public class MyOptionConfigurer extends OptionConfigurer {

    @Override
    public void configure(Configurable configurable) {
        configurable.configureOptionsFor( MongoDB.class )
            .writeConcern( WriteConcernType.JOURNALED )
            .entity( Zoo.class )
                .associationStorage( AssociationStorageType.ASSOCIATION_DOCUMENT )
                .associationDocumentStorage( AssociationDocumentType.COLLECTION_PER_ASSOCIATION )
                .property( "animals", ElementType.FIELD )
                    .associationStorage( AssociationStorageType.IN_ENTITY )
            .entity( Animal.class )
                .associationStorage( AssociationStorageType.ASSOCIATION_DOCUMENT );
    }
}
----
====

The call to +configureOptionsFor()+, passing the store-specific identifier type +MongoDB+,
provides the entry point into the API. Following the fluent API pattern, you then can configure
global options and navigate to single entities or properties to apply options specific to these.

Options given on the property level precede entity-level options. So e.g. the +animals+ association of the +Zoo+
class would be stored using the in-entity strategy, while all other associations of the +Zoo+ entity would
be stored using separate association documents.

Similarly, entity-level options take precedence over options given on the global level.
Global-level options specified via the API complement the settings given via configuration properties.
In case a setting is given via a configuration property and the API at the same time,
the latter takes precedence.

To register an option configurer, specify its name using the +hibernate.ogm.option.configurer+ property.
When bootstrapping a session factory or entity manager factory programmatically,
you also can pass in an +OptionConfigurer+ instance or the class object representing the configurer type.


[[ogm-mongodb-storage-prinicples]]
==== Storage principles

Hibernate OGM tries to make the mapping to the underlying datastore as natural as possible
so that third party applications not using Hibernate OGM can still read
and update the same datastore.
We worked particularly hard on the MongoDB model
to offer various classic mappings between your object model
and the MongoDB documents.

===== Entities

Entities are stored as MongoDB documents and not as BLOBs
which means each entity property will be translated into a document field.
You can use the name property of the [classname]+@Table+ and [classname]+@Column+ annotations
to rename the collections and the document's fields if you need to.

Note that embedded objects are mapped as nested documents.

.Example of an entity with an embedded object
====
[source, JAVA]
----
@Entity
public class News {
    @Id
    private String id;
    private String title;
    @Column(name="desc")
    private String description;
    @Embedded
    private NewsPaper paper;

    //getters, setters ...
}

@Embeddable
public class NewsPaper {
    private String name;
    private String owner;
    //getters, setters ...
}
----

[source, JSON]
----
{
    "_id" : "1234-5678-0123-4567",
    "title": "On the merits of NoSQL",
    "desc": "This paper discuss why NoSQL will save the world for good",
    "paper": {
        "name": "NoSQL journal of prophecies",
        "owner": "Delphy"
    }
}
----
====

====== Identifiers

The +_id+ field of a MongoDB document is directly used
to store the identifier columns mapped in the entities.
That means you can use simple identifiers (no matter the Java type used)
as well as Embedded identifiers.
Embedded identifiers are stored as embedded document into the +_id+ field.
Hibernate OGM will convert the +@Id+ property into a +_id+ document field
so you can name the entity id like you want it will always be stored into +_id+
(the recommended approach in MongoDB).
That means in particular that MongoDB will automatically index your _id fields.
Let's look at an example:

.Example of an entity using Embedded id
====
[source, JAVA]
----
@Entity
public class News {

    @EmbeddedId
    private NewsID newsId;
    //getters, setters ...
}

@Embeddable
public class NewsID implements Serializable {

    private String title;
    private String author;
    //getters, setters ...
}
----

[source, JSON]
----
{
    "_id" :{
        "title": "How does Hibernate OGM MongoDB work?",
        "author": "Guillaume"
    }
}
----
====

===== Associations

Hibernate OGM MongoDB proposes three strategies to store navigation information for associations.
To switch between these strategies,
either use the +@AssocationStorage+ and +@AssociationDocumentStorage+ annotations (see <<ogm-mongodb-annotation-configuration>>),
the API for programmatic configuration (see <<ogm-mongodb-programmatic-configuration>>) or
specify a default strategy via the +hibernate.ogm.datastore.document.association_storage+ and
+hibernate.ogm.mongodb.association_document_storage+ configuration properties.

The three possible strategies are:

* IN_ENTITY (default)
* ASSOCIATION_DOCUMENT, using a global collection for all associations
* ASSOCIATION_DOCUMENT, using a dedicated collection for each association

====== In Entity strategy

In this strategy, Hibernate OGM directly stores the id(s)
of the other side of the association
into a field or an embedded document
depending if the mapping concerns a single object or a collection.
The field that stores the relationship information is named like the entity property.

.Java entity
====
[source, JAVA]
----
@Entity
public class AccountOwner {

    @Id
    private String id;

    @ManyToMany
    public Set<BankAccount> bankAccounts;

    //getters, setters, ...
}
----
====

.JSON representation
====
[source, JSON]
----
{
    "_id" : "owner0001",
    "bankAccounts" : [
        { "bankAccounts_id" : "accountXYZ" }
    ]
}
----
====

====== Global collection strategy

With this strategy, Hibernate OGM creates a single collection
in which it will store all navigation information for all associations.
Each document of this collection is structure in 2 parts.
The first is the +_id+ field which contains the identifier information
of the association owner and the name of the association table.
The second part is the +rows+ field which stores (into an embedded collection) all ids
that the current instance is related to.

.Unidirectional relationship
====
[source, JSON]
----
{
    "_id": {
        "owners_id": "owner0001",
        "table": "AccountOwner_BankAccount"
    },
    "rows": [
        { "bankAccounts_id": "accountXYZ" }
    ]
}
----
====

For a bidirectional relationship, another document is created where ids are reversed.
Don't worry, Hibernate OGM takes care of keeping them in sync:

.Bidirectional relationship
====
[source, JSON]
----
{
    "_id": {
        "owners_id": "owner0001",
        "table": "AccountOwner_BankAccount"
    },
    "rows": [{
        "bankAccounts_id": "accountXYZ"
        }]
}
{
    "_id": {
        "bankAccounts_id": "accountXYZ",
        "table": "AccountOwner_BankAccount"
    },
    "rows": [{
        "owners_id": "owner0001"
    }]
}
----
====

====== One collection per association strategy

In this strategy, Hibernate OGM creates a MongoDB collection per association
in which it will store all navigation information for that particular association.
This is the strategy closest to the relational model.
If an entity A is related to B and C, 2 collections will be created.
The name of this collection is made of the association table concatenated with +associations_+.
For example, if the [classname]+BankAccount+ and [classname]+Owner+ are related,
the collection used to store will be named +associations_Owner_BankAccount+.
The prefix is useful to quickly identify the association collections from the entity collections.
Each document of an association collection has the following structure:

* +_id+ contains the id of the owner of relationship
* +rows+ contains all the id of the related entities

.Unidirectional relationship
====
[source, JSON]
----
{
    "_id" : { "owners_id" : "owner0001" },
    "rows" : [
        { "bankAccounts_id" : "accountXYZ" }
    ]
}
----
====

.Bidirectional relationship
====
[source, JSON]
----
{
    "_id" : { "owners_id" : "owner0001" },
    "rows" : [
        { "bankAccounts_id" : "accountXYZ" }
    ]
}
{
    "_id" : { "bankAccounts_id" : "accountXYZ" },
    "rows" : [
        { "owners_id" : "owner0001" }
    ]
}
----
====

==== Transactions

MongoDB does not support transactions.
Only changes applied to the same document are done atomically.
A change applied to more than one document will not be applied atomically.
This problem is slightly mitigated by the fact that Hibernate OGM queues all changes
before applying them during flush time.
So the window of time used to write to MongoDB is smaller than what you would have done manually.

We recommend that you still use transaction demarcations with Hibernate OGM
to trigger the flush operation transparently (on commit).
But do not consider rollback as a possibility, this won't work.

==== Queries

Hibernate OGM is a work in progress, so only a sub-set of JP-QL constructs is available
when using the JP-QL query support. This includes:

* simple comparisons using "<", "<=", "=", ">=" and ">"
* +IS NULL+ and +IS NOT NULL+
* the boolean operators +AND+, +OR+, +NOT+
* +LIKE+, +IN+ and +BETWEEN+

Queries using these constructs will be transformed into equivalent native MongoDB queries.
In cases where this is not enough, you have two additional strategies to query entities stored by Hibernate OGM:

* use native MongoDB queries
* use Hibernate Search

Because Hibernate OGM stores data in MongoDB in a natural way,
you can use the MongoDB driver and execute queries on the datastore directly
without involving Hibernate OGM.
The benefit of this approach is to use the query capabilities of MongoDB.
The drawback is that raw MongoDB documents will be returned and not managed entities.

The alternative approach is to index your entities with Hibernate Search.
That way, a set of secondary indexes independent of MongoDB is maintained by Hibernate Search
and you can write queries on top of them.
The benefit of this approach is an nice integration at the JPA / Hibernate API level
(managed entities are returned by the queries).
The drawback is that you need to store the Lucene indexes somewhere
(file system, infinispan grid etc).
Have a look at the Infinispan section for more info on how to use Hibernate Search.
