[[ogm-neo4j]]

=== Neo4j

http://www.neo4j.org[Neo4j] is a robust (fully ACID) transactional property graph database.
This kind of databases are suited for those type of problems that can be represented with a graph 
like social relationships or road maps for example.

At the moment only the support for the embedded Neo4j is included in OGM.

This is our first version and a bit experimental. In particular we plan on using node navigation much more than index lookup in a future version.

==== How to add Neo4j integration

.1. Add the dependencies to your project
If your project uses Maven you can add this to the pom.xml: 

[source, XML]
[subs="verbatim,attributes"]
----
<dependency>
    <groupId>org.hibernate.ogm</groupId>
    <artifactId>hibernate-ogm-neo4j</artifactId>
    <version>{hibernate-ogm-version}</version>
</dependency>
----
Alternatively you can find the required libraries in the distribution package on https://downloads.sourceforge.net/project/hibernate/hibernate-ogm/{hibernate-ogm-version}/hibernate-ogm-{hibernate-ogm-version}-dist.zip[SourceForge]

.2. Add the following properties:

[source, properties]
[subs="verbatim,attributes"]
----
hibernate.ogm.datastore.provider = neo4j_embedded
hibernate.ogm.neo4j.database_path = C:\example\mydb
----

==== Configuring Neo4j

The following properties are available to configure Neo4j support:

.Neo4j datastore configuration properties
hibernate.ogm.neo4j.database_path::
The absolute path representing the location of the Neo4j database. Example: +C:\neo4jdb\mydb+
hibernate.ogm.neo4j.configuration_resource_name (optional)::
Location of the Neo4j embedded properties file. It can be an URL, name of a classpath resource or file system path.

[NOTE]
====
When bootstrapping a session factory or entity manager factory programmatically,
you should use the constants accessible via +Neo4jProperties+
when specifying the configuration properties listed above.
Common properties shared between stores are declared on +OgmProperties+.
To ease migration between stores, it is recommended to reference these constants directly from there.
====

[[ogm-neo4j-storage-principles]]
==== Storage principles

Hibernate OGM tries to make the mapping to the underlying datastore as natural as possible
so that third party applications not using Hibernate OGM can still read
and update the same datastore.

[WARNING]
====
The mappings are still EXPERIMENTAL and they might change in future.
====

===== Entities

Entities are stored as Neo4j nodes, which means each entity property will be translated into a property of the node.
The name of the table mapping the entity is used as label.

You can use the name property of the [classname]+@Table+ and [classname]+@Column+ annotations
to rename the label and the node's properties.

An additional label +ENTITY+ is added to the node. 

.Example of entity and the corresponding representation using Cypher
====
[source, JAVA]
----
@Entity
class Account {

    @Id
    String login;

    String password;

}
----

[subs="verbatim,attributes"]
----
Using Cypher:

(n:Account:ENTITY {login: '...', password: '...'})
----
====

===== Associations

An association, bidirectional or unidirectional, is always mapped using one relationship.
This is possible because in Neo4j relationships can be navigated in both directions.

The type of the relationships depends on the type of the association, but in general, it is the corresponding name of the table
containing the association.

[WARNING]
====
Unidirectional many-to-one associations are currently an exception to this rule.
At the moment, in this scenario, there won't be a relationship.
====

The ids of the entities connected to the relationship are stored as properties.
In the following examples we omitted the properties containing the id for simplicity and because we are planning to remove them
in the future.

.Example of bidirectional @ManyToMany
====
[source, JAVA]
----
@Entity
class AccountOwner {

    @Id
    String sSN;

    @ManyToMany
    Set<BankAccount> bankAccounts = new HashSet<BankAccount>();

}

@Entity
class BankAccount {

    @Id
    String accountNumber;

    @ManyToMany(mappedBy = "bankAccounts")
    Set<AccountOwner> owners = new HashSet<AccountOwner>();

}
----

[subs="verbatim,attributes"]
----
(:AccountOwner:ENTITY {...}) - [:AccountOwner_BankAccount] - (:BankAccount:ENTITY {...})
----

====

.Example of unidirectional @ManyToOne with @OrderColumn
====
[source, JAVA]
----
@Entity
class Father {
    @Id
    String name;

    @OneToMany
    @JoinTable(name = "Father_child")
    @OrderColumn(name = "birthorder")
    List<Child> children = new ArrayList<Child>();
}

@Entity
class Child {
    @Id
    String name;
}

----

[subs="verbatim,attributes"]
----
(:Father:ENTITY {...}) - [:Father_child { birthorder: 0 }] - (child0:Child:ENTITY {...})
(:Father:ENTITY {...}) - [:Father_child { birthorder: 1 }] - (child1:Child:ENTITY {...})
----

====

===== Auto Generated Values

Hibernate OGM only supports the table generation strategy in Neo4j.
A sequence is represented by a node like in the following example:

.Example of a sequence using cypher
====
[subs="verbatim,attributes"]
----
(sequence:GeneratorKey:SEQUENCE {sequence_name: '...', current_value: '...'})
----
====

A sequence node is labeled with the constant +SEQUENCE+ and with the generator key of the sequence.
A unique constraint is applied on the property +sequence_name+ to avoid the same sequence name is used twice in nodes having the same generator key.
The property +current_value+ stores the next value of the sequence.

Note that when a different strategy is selected for an entity, we won't throw an exception but we will fall-back to this representation. The only difference is that we will apply
a default generator key as label.

==== Transactions

Neo4j operations can be executed only inside a transaction.
Unless a different +org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform+ is specified, OGM will use a default one to integrate with the Neo4j transaction mechanism.
This means that you can start and commit transaction using the Hibernate session.

The drawback is that it is not possible at the moment to let Neo4j participate in managed JTA transactions spanning several resources (see issue https://hibernate.atlassian.net/browse/OGM-370[OGM-370]).

.Example of starting and committing transactions
====
[source, JAVA]
----
Session session = factory.openSession();
Transaction tx = session.beginTransaction();

Account account = new Account();
account.setLogin( "myAccount" );
session.persist( account );

tx.commit();

...

tx = session.beginTransaction();
Account savedAccount =  (Account) session.get( Account.class, account.getId() );
tx.commit();
----
====

[[ogm-neo4j-queries]]
==== Queries

You can express queries in a few different ways:

* using JP-QL
* using the Cypher query language
* using a Hibernate Search query (brings advanced full-text and geospatial queries)

===== JP-QL queries

Hibernate OGM is a work in progress, so only a sub-set of JP-QL constructs is available
when using the JP-QL query support. This includes:

* simple comparisons using "<", "<=", "=", ">=" and ">"
* +IS NULL+ and +IS NOT NULL+
* the boolean operators +AND+, +OR+, +NOT+
* +LIKE+, +IN+ and +BETWEEN+
* +ORDER BY+

Queries using these constructs will be transformed into equivalent http://docs.neo4j.org/chunked/stable/cypher-query-lang.html[Cypher queries].

===== Cypher queries

Hibernate OGM also supports http://docs.neo4j.org/chunked/stable/cypher-query-lang.html[Cypher queries] for Neo4j.
You can execute Cypher queries as shown in the following example:

.Using the JPA API
====
[source, JAVA]
----
@Entity
public class Poem {

    @Id
    private Long id;

    private String name;

    private String author;

   // getters, setters ...

}

...

javax.persistence.EntityManager em = ...

// a single result query
String query1 = "MATCH ( n:Poem { name:'Portia', author:'Oscar Wilde' } ) RETURN n";
Poem poem = (Poem) em.createNativeQuery( query1, Poem.class ).getSingleResult();

// query with order by
String query2 = "MATCH ( n:Poem { name:'Portia', author:'Oscar Wilde' } ) " +
                "RETURN n ORDER BY n.name";
List<Poem> poems = em.createNativeQuery( query2, Poem.class ).getResultList();

// query with projections
String query3 = MATCH ( n:Poem ) RETURN n.name, n.author ORDER BY n.name";
List<Object[]> poemNames = (List<Object[]>)em.createNativeQuery( query3 )
                               .getResultList();

----
====

The result of a query is a managed entity (or a list thereof) or a projection of attributes in form of an object array,
just like you would get from a JP-QL query.

.Using the Hibernate native API
====
[source, JAVA]
----
OgmSession session = ...

String query1 = "MATCH ( n:Poem { name:'Portia', author:'Oscar Wilde' } ) " + 
                "RETURN n";
Poem poem = session.createNativeQuery( query1 )
                      .addEntity( "Poem", Poem.class )
                      .uniqueResult();

String query2 = "MATCH ( n:Poem { name:'Portia', author:'Oscar Wilde' } ) " + 
                "RETURN n ORDER BY n.name";
List<Poem> poems = session.createNativeQuery( query2 )
                      .addEntity( "Poem", Poem.class )
                      .list();
----
====

[NOTE]
====
As +OgmSession+ extends +org.hibernate.Session+ (which originally has been designed with relational databases in mind only)
you could also invoke +createSQLQuery()+ to create a native query. But for the sake of comprehensibility, you should prefer
+createNativeQuery()+, and in fact +createSQLQuery()+ has been deprecated on +OgmSession+.
====

Native queries can also be created using the +@NamedNativeQuery+ annotation:

.Using @NamedNativeQuery
====
[source, JAVA]
----
@Entity
@NamedNativeQuery(
   name = "AthanasiaPoem",
   query = "MATCH ( n:Poem { name:'Athanasia', author:'Oscar Wilde' } ) RETURN n",
   resultClass = Poem.class )
public class Poem { ... }

...

// Using the EntityManager
Poem poem1 = (Poem) em.createNamedQuery( "AthanasiaPoem" )
                     .getSingleResult();

// Using the Session
Poem poem2 = (Poem) session.getNamedQuery( "AthanasiaPoem" )
                     .uniqueResult();
----
====

Hibernate OGM stores data in a natural way so you can still execute queries using your favorite tool,
the main drawback is that the results are going to be raw Neo4j elements and not managed entities.

===== Hibernate Search

You can index your entities using Hibernate Search.
That way, a set of secondary indexes independent of Neo4j is maintained by Hibernate Search
and you can write queries on top of them.
The benefit of this approach is a nice integration at the JPA / Hibernate API level
(managed entities are returned by the queries).
The drawback is that you need to store the Lucene indexes somewhere
(file system, infinispan grid, etc).
Have a look at the Infinispan section (<<ogm-infinispan-indexstorage>>)
for more info on how to use Hibernate Search.


